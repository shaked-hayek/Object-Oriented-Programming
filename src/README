shaked.hayek
shirlevy

#################################################
############ Questions from exercise ############
#################################################

### Exceptions - report in your README file how you handled s-Java code errors in this exercise:
We chose to create an SjavacException class that all other exceptions extend.
We chose to have a general exception class for each issue group, and have a specific message for each
specific error.
We chose to throw the exception in the place that it was detected, and only catch it in the main Sjavac
class, where we printed the exception class name, the message and the line / method name in which the issue
occurred. We chose to print the error with this additional information in order to make it easier for users
to find the error.
At first we thought we should have a different Exception class for each different case of invalid text in the
file. But we soon found out that there are many different reasons for exceptions and that it is better to
create a class for each general type of problem, and let the classes that throws those exceptions add a
relevant error message. That way we managed to have less classes, we managed to allow the users to get more
specific information about the error occurred, and also give the throwing class the responsibility to
specify the problem occurred.

### You are required to specify your design, as well as your thinking process and the alternatives you
    ruled out
We chose to have the main class responsibility be to print errors and information about the program outcome.
Also we chose that it will be the only part in the code that is responsible on opening and managing the file
stream.

We chose to have two classes that manage each a single pass on all the text. We wanted to have a first pass
to validate each line, and process lines that are outside of methods and method declarations. That way we
can ignore the location of global variables and methods, and save them in the relevant data structures.
We wanted to have a second pass only on the content of the methods. This is why we created LineValidator that
validate each line independently, and we created MethodValidator that validates each method in it's context.

We chose to have a Scope class that held all of the information about it's scope. We had GlobalScope extend
it and add it's own functionality XXXXXXXXXX

VarTypeFactory - why we chose factory XXXXXXXX

functional programming in VarTypeFactory XXXXXXXX

### How would you modify your code to add new types of variables (e.g., float)?
If we wanted to add a new type of variable, all we had to do was add to the Enum (VarType) the name of the
type, and add to the class VarTypeFactory the new type - that would require:
 * Adding the type to the switch statement in the getType method
 * Adding a regex pattern that checks a valid value to this type
 * Adding the getValValidationFunc method a lambda expression that checks this regex
This is an implementation of the Single Choice principle, because there is only one main object that knows
all of the different types. Adding a new type requires change in that class alone.
The types doesn't appear anywhere else in the project, besides the class VarTypeFactory and the enum VarType.

### Modifications/extensions we would have to make in our code to support these additions:
## Using methods of standard java (i.e System.out.println)
In order to allow using standard methods, we can add a class of StandardJavaScope extending GlobalScope,
that loads all of the methods in the standard library to the methodHashMap. We will need to create for each
a Method object that specifies it's expected parameters.
Then we can just have the globalScope check the map of StandardJavaScope as well when looking for existing
methods (at getMethodFromMap method). That will be the only change necessary in order to allow this addition.
## Classes
In order to support classes we could add another class that extends GlobalScope.
We had Method receive general parent scope (and not necessarily the global scope) so that it is irrelevant
for the method what is it's parent scope. We did the same with the variables. Because of that, the addition
of classes requires no change in the Method and Variable classes.
We will only need to add to the LineValidator an option for processing class declarations, and creating the
object of a class.

### REGEX -  please describe two of the main regular expressions you used in your code:
All of the regex patterns in our program are compiled only once for efficiency.
1. The regex pattern for a valid name of a variable: "([a-zA-Z][a-zA-Z0-9_]*|_[a-zA-Z0-9_]+)".
This regex only matches a name that starts with a letter and then can contain letters, numbers and _, OR
starts with _, but doesn't matches _.
In order to do that we divided the pattern into 2 parts with or on between.
2. The regex pattern for a valid double value: "([\+|\-]?\d+\.?\d*)|([\+|\-]?\d*\.?\d+)".
We had to allow matching of few different options -
* Having zero or one + or - sign at the beginning, that is why we had the expression [\+|\-]?. The ? allows
one or zero.
* Having a numbers with dot in the muddle, beginning or end but not allowing a dot alone. We chose to capture
that with allowing two options, where in both we must have at least one number.
We also wanted to capture the group chosen. That is why we put () around the two options.


#####################################
############### TESTS ###############
#####################################

test 1: make sure we skip whitespaces and comments
test 2: make sure valid declaration and initialization of non-final variables
test 3: make sure variable names are valid
test 4: make sure final initialization is valid for all types
test 5: make sure a function is able to get a final variable
test 6: make sure double value is valid for boolean variable
test 7: make sure int value is valid for boolean variable
test 8: make sure int value is valid for double variable
test 9: make sure String initialization is valid (with spaces and signs)
test 10: make sure assignment of declared String and int in same line is valid.
test 11: make sure all options of double are valid
test 12: make sure name of variable and function is the same - valid
test 13: make sure global variable is initialized only after a function where it's used - valid
test 14: make sure functions calls are valid
test 15: make sure function recursive calls are valid
test 16: make sure conditions in if are valid
test 17: make sure conditions with "||" (or) and "&&" (and)
test 18: make sure return in function is valid as long as there's return statement in the last line of it
test 19: make sure while scope inside of if scope many times is valid
test 20: make sure same variable name for variables in different scopes is valid

